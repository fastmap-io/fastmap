#!/usr/bin/env python3

import argparse
import importlib
import json
import os
import sys

import dill
import tabulate
import fastmap

USAGE = """Fastmap CLI for running arbitrary Python functions on the cloud.
This CLI only supports the offload workflow and doesn't have any mapping functionality.
Run `fastmap --help` for more details.
"""

DESCRIPTION = """
Fastmap CLI for offloading scripts.
\n\n
Examples:
$ fastmap offload <path/to/script.py> <function_name>
$ fastmap poll <task_id>
$ fastmap poll
$ fastmap logs <task_id>
$ fastmap result <task_id> --output-file=save.json
$ fastmap kill <task_id>
$ fastmap clear <task_id>


"""

EPILOG = """Run `fastmap <operation> --help` for help on individual operations."""


def offload(config, path, function_name, label):
    if not os.path.exists(path):
        raise AssertionError("Path %r does not exist." % path)
    mod_path = path.replace('/', '.')
    if mod_path.endswith('.py'):
        mod_path = mod_path[:-3]
    sys.path.append(os.getcwd())
    try:
        mod = importlib.import_module(mod_path)
    except ImportError:
        raise AssertionError("Could not import module %r" % mod_path) from None

    try:
        func = getattr(mod, function_name)
    except AttributeError:
        raise AssertionError("Could not import function %r from module %r" %
                             (func, mod_path)) from None
    fastmap_task = config.offload(func, label=label)
    print("Task_ID: %s" % fastmap_task.task_id)


def poll(config, task_id):
    if task_id:
        tasks = [config.poll(task_id)]
    else:
        tasks = config.poll_all()

    tasks.sort(key=lambda x: x['start_time'], reverse=True)

    for task in tasks:
        task['start_time'] = task['start_time'].strftime("%Y-%m-%d %H:%M:%S")
        task['runtime'] = task['runtime'] and round(task['runtime'], 2)

    print("Found %d task(s)" % len(tasks))
    print(tabulate.tabulate(tasks, headers='keys'))


def result(config, task_id, output_format, output_file):
    _result = config.result(task_id)
    if output_format == "json":
        _result = json.dumps(dill.loads(_result))
    if output_file:
        with open(output_file, 'w') as f:
            f.write(_result)
        print("Wrote result to %r" % output_file)
    else:
        print(_result)


def kill(config, task_id):
    config.kill(task_id)


def logs(config, task_id):
    logs = config.logs(task_id)
    print("Logs for %s" % task_id)
    print(logs)


def clear(config, task_id):
    if task_id:
        config.clear(task_id)
    else:
        config.clear_all()


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        # usage=DESCRIPTION,
        description=DESCRIPTION,
        epilog=EPILOG,
        formatter_class=argparse.RawDescriptionHelpFormatter)

    parser.add_argument(
        "--config",
        required=True,
        help="Location of configuration file generated by "
             "depoly_gcp.py. Required.")
    parser.add_argument(
        "--verbosity",
        choices=("QUIET", "NORMAL", "LOUD"),
        help="How loud fastmap is. Default is NORMAL.",
        default="NORMAL")

    subparsers = parser.add_subparsers(
        dest='operation', required=True,
        help='sub-command help')

    offload_p = subparsers.add_parser(
        'offload',
        help="Offload a function in a python file.")
    offload_p.add_argument(
        "path",
        help="The python file. E.g. path/script.py")
    offload_p.add_argument(
        "function",
        help="The name of the function in the file. E.g. main_function")
    offload_p.add_argument(
        "label",
        nargs='?',
        help="Optional label for your use")

    poll_p = subparsers.add_parser(
        'poll', help="Get the metadata of one or all tasks")
    poll_p.add_argument(
        "task_id", nargs='?',
        help="Which task to return specifically. If omitted, return all non-CLEARED tasks")

    logs_p = subparsers.add_parser(
        'logs',
        help="Get logs of a task. Task can be in any state.")
    logs_p.add_argument(
        "task_id",
        help="Task ID of task to get logs for.")

    result_p = subparsers.add_parser(
        'result',
        help="Get the result of a task in a DONE state.")
    result_p.add_argument(
        "task_id",
        help="Task ID")
    result_p.add_argument(
        "--output-format", choices=["dill", "json"],
        default="json", help="Convert output to format. Default is json.")
    result_p.add_argument(
        "--output-file",
        help="File to send the result to. If omitted, send result to stdout "
             "while redirecting regular stdout to stderr.")

    kill_p = subparsers.add_parser(
        'kill',
        help="Kill a running task")
    kill_p.add_argument(
        "task_id",
        help="Task ID of task to kill.")

    clear_p = subparsers.add_parser(
        'clear',
        help="Clear a completed task")
    clear_p.add_argument(
        "task_id", nargs='?',
        help="If omitted, clear all tasks")

    args = parser.parse_args()

    config = fastmap.init(
        config=args.config,
        verbosity=args.verbosity)

    if args.operation == 'offload':
        offload(config, args.path, args.function, args.label)
    if args.operation == 'poll':
        poll(config, args.task_id)
    if args.operation == 'result':
        result(config, args.task_id, args.output_format, args.output_file)
    if args.operation == 'kill':
        kill(config, args.task_id)
    if args.operation == 'logs':
        logs(config, args.task_id)
    if args.operation == 'clear':
        clear(config, args.task_id)
